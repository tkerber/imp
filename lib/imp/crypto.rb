require 'openssl'

module Imp
  
  # Contains methods for easily interfacing with ruby's encryption algorithms.
  # Uses 256 bit AES in CBC mode with keys generated by PBKDF2 using SHA1
  # and 10 000 iterations.
  module Crypto
    
    # The length of the key to use.
    # This module used AES-256, which has a key length of 32 bytes.
    KEYLEN = 32
    # The block size of the cipher.
    # As this module uses AES, this is 16 bytes.
    BLOCK_SIZE = 16
    # The length of the salts to generate. The length is used as that of the
    # key.
    SALTLEN = KEYLEN
    # The iteration of the PBKDF2 algorim to go through.
    ITER = 10_000
    # The mode of AES to use.
    MODE = :CBC
    
    # Delegates key generation to PBKDF2
    # 
    # @param passwd [String] The password.
    # @param salt [String] The salt.
    # @return [String] The key.
    def self.get_key(passwd, salt)
      OpenSSL::PKCS5.pbkdf2_hmac_sha1(passwd, salt, ITER, KEYLEN)
    end
    
    # Gets a random salt.
    # 
    # @return [String] A salt.
    def self.rand_salt
      OpenSSL::Random.random_bytes SALTLEN
    end
    
    # Encrypts a string. The result is the IV, followed by the actual
    # encrypted string.
    # 
    # @param key [String] The key.
    # @param data [String] The unencrypted data.
    # @return [String] The encrypted data.
    def self.encrypt(key, data)
      cipher = OpenSSL::Cipher::AES.new(KEYLEN * 8, MODE)
      cipher.encrypt
      iv = cipher.random_iv
      cipher.key = key
      
      iv + cipher.update(data) + cipher.final
    end
    
    # Decrypts a string encrypted by ::encrypt
    # 
    # @param key [String] The key.
    # @param data [String] The encrypted data.
    # @return [String] The unencrypted data.
    def self.decrypt(key, data)
      cipher = OpenSSL::Cipher::AES.new(KEYLEN * 8, MODE)
      cipher.decrypt
      cipher.iv = data.byteslice 0...BLOCK_SIZE
      cipher.key = key
      
      cipher.update(data.byteslice BLOCK_SIZE..-1) + cipher.final
    end
    
  end
  
end
